
#if UNITY_EDITOR

namespace Spineless
{
	using System;
	using System.Collections.Generic;
	using System.IO;
	using System.Text;
	using UnityEditor;
	using UnityEngine;


	public class CodeGenerator
	{
		private string classNamespace;
		private string className;
		private string classDescription;
		private string outputDirectory = "Scripts";
		private bool isStatic;
		private Dictionary<string, object> constants;


		#region Constructors
		public CodeGenerator(string className)
		{
			this.className = className;
			this.constants = new Dictionary<string, object>();
		}
		#endregion


		#region Properties
		/// <summary>
		/// Description/summary of class, to be included in XML documentation.
		/// </summary>
		public string ClassDescription
		{
			get { return this.classDescription; }
			set { this.classDescription = value; }
		}


		/// <summary>
		/// Name of the class being generated.
		/// </summary>
		public string ClassName
		{
			get { return this.className; }
			set { this.className = value; }
		}


		/// <summary>
		/// Option namespace of class.
		/// </summary>
		public string ClassNamespace
		{
			get { return this.classNamespace; }
			set { this.classNamespace = value; }
		}


		/// <summary>
		/// Public constants to be generated.
		/// </summary>
		public Dictionary<string, object> Constants
		{
			get { return this.constants; }
			set { this.constants = value; }
		}


		/// <summary>
		/// Whether generated class should be static.
		/// </summary>
		public bool IsStatic
		{
			get { return this.isStatic; }
			set { this.isStatic = value; }
		}


		/// <summary>
		/// Directory, relative to Assets, where class should be generated.
		/// </summary>
		public string OutputDirectory
		{
			get { return this.outputDirectory; }
			set { this.outputDirectory = value; }
		}
		#endregion


		/// <summary>
		/// Add a public constant to the class.
		/// </summary>
		/// <param name="name">Name of the constant.</param>
		/// <param name="value">Value of the constant. Type will be inferred.</param>
		public void AddConstant(string name, object value)
		{
			this.constants.Add(name, value);
		}


		/// <summary>
		/// Write class to file.
		/// </summary>
		public void WriteCodeToFile()
		{
			// Format path to use proper directory separators.
			string filePath = this.outputDirectory
				.Replace('/', Path.DirectorySeparatorChar)
				.Replace('\\', Path.DirectorySeparatorChar)
				.TrimEnd(Path.DirectorySeparatorChar);
			filePath = string.Concat(
				Application.dataPath,
				Path.DirectorySeparatorChar,
				this.OutputDirectory,
				Path.DirectorySeparatorChar,
				this.className,
				".cs");

			// Try to write to file.
			try
			{
				// opens the file if it allready exists, creates it otherwise
				using (FileStream stream = File.Open(filePath, FileMode.OpenOrCreate, FileAccess.Write))
				{
					using (StreamWriter writer = new StreamWriter(stream))
					{
						StringBuilder builder = new StringBuilder();
						AutoIndent indent = new AutoIndent();

						// Header.
						builder.AppendLine("// ------------------------------------------------------------------------------")
							.AppendLine("// <auto-generated>")
							.AppendLine("// \tThis code was generated by a tool.")
							.AppendLine("//")
							.AppendLine("// \tChanges to this file may cause incorrect behavior and will be lost if")
							.AppendLine("// \tthe code is regenerated.")
							.AppendLine("// </auto-generated>")
							.AppendLine("// ------------------------------------------------------------------------------");

						// Namespace begin.
						if (!string.IsNullOrEmpty(this.classNamespace))
						{
							builder.AppendLine("namespace " + this.classNamespace)
								.AppendLine("{");
							indent.IncreaseIndent();
						}

						// Class begin.
						if (this.classDescription != null)
						{
							builder.AppendLine(indent + "/// <summary>")
								.AppendLine(indent + "/// " + this.classDescription)
								.AppendLine(indent + "/// </summary>");
						}
						builder.AppendLine(
							string.Concat(
								indent,
								"public ",
								this.isStatic ? "static " : "",
								"class ",
								this.className
								));
						builder.AppendLine(indent + "{");
						indent.IncreaseIndent();

						// Constants.
						foreach (KeyValuePair<string, object> entry in this.constants)
						{
							string type;
							if (entry.Value is string)
								type = "string";
							else if (entry.Value is int)
								type = "int";
							else if (entry.Value is double)
								type = "double";
							else if (entry.Value is float)
								type = "float";
							else
								type = entry.Value.GetType().Name;

							builder.AppendLine(
								String.Concat(
									indent,
									"public const ",
									type,
									" ",
									entry.Key,
									" = ",
									entry.Value is string ? "\"" : "",
									entry.Value.ToString(),
									entry.Value is string ? "\"" : "",
									";"));
						}

						// Class end.
						indent.DecreaseIndent();
						builder.AppendLine(indent + "}");

						// Namespace end.
						if (!string.IsNullOrEmpty(this.classNamespace))
						{
							indent.DecreaseIndent();
							builder.AppendLine("}");
						}

						writer.Write(builder.ToString());
					}
				}
			}

				// Errors are generally a corrupt file. 
				// Delete file if that happens, so it can be replaced.
			catch (Exception e)
			{
				Debug.LogException(e);
				if (File.Exists(filePath))
					File.Delete(filePath);
			}

			AssetDatabase.Refresh();
		}


		private class AutoIndent
		{
			private int indentLevel = 0;


			#region Operators
			/// <summary>
			/// Return appropriate number of tab characters according to indent level.
			/// </summary>
			/// <param name="autoIndent"></param>
			public static implicit operator string(AutoIndent autoIndent)
			{
				StringBuilder stringBuilder = new StringBuilder();

				for (int i = 0; i < autoIndent.indentLevel; i++)
				{
					stringBuilder.Append("\t");
				}

				return stringBuilder.ToString();
			}
			#endregion


			/// <summary>
			/// Decrease indent by one tab.
			/// </summary>
			public void DecreaseIndent()
			{
				if (this.indentLevel > 0)
					this.indentLevel--;
			}


			/// <summary>
			/// Increase indent by one tab.
			/// </summary>
			public void IncreaseIndent()
			{
				this.indentLevel++;
			}


			/// <summary>
			/// Set indent manually.
			/// Must be over zero.
			/// </summary>
			/// <param name="indentLevel"></param>
			public void SetIndentLevel(int indentLevel)
			{
				if (indentLevel < 0)
					indentLevel = 0;
				this.indentLevel = indentLevel;
			}
		}
	}
}

#endif